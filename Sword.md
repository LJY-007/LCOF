## Table of Contents
|åºå·|é¢˜ç›®|éš¾åº¦|æ ‡ç­¾|LeetCode|
|:-:|:-|:-:|:-|:-:|
|1|[]()||||
|2|[]()||||
|3|[]()||||
|4|[äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾](#4-äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾)|Easy|`æ•°ç»„`|240|
|5|[]()||||
|6|[]()||||
|7|[]()||||
|8|[]()||||
|9|[ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—](#9-ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—)|Easy|`æ ˆ` `é˜Ÿåˆ—`|~|
|10|[]()||||
|11|[]()||||
|12|[]()||||
|13|[]()||||
|14|[]()||||
|15|[]()||||
|16|[]()||||
|17|[]()||||
|18|[]()||||
|19|[]()||||
|20|[]()||||
|21|[]()||||
|22|[]()||||
|23|[]()||||
|24|[åè½¬é“¾è¡¨](#24-åè½¬é“¾è¡¨)|Easy|`é“¾è¡¨`|206|
|25|[]()||||
|26|[]()||||
|27|[]()||||
|28|[]()||||
|29|[é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](#29-é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ)|Easy|`æ•°ç»„`|54|
|30|[åŒ…å«minå‡½æ•°çš„æ ˆ](#30-åŒ…å«minå‡½æ•°çš„æ ˆ)|Easy|`æ ˆ`|155|
|31|[]()||||
|32|[]()||||
|33|[]()||||
|34|[]()||||
|35|[]()||||
|36|[]()||||
|37|[]()||||
|38|[]()||||
|39|[]()||||
|40|[]()||||
|41|[æ•°æ®æµä¸­çš„ä¸­ä½æ•°](#41-æ•°æ®æµä¸­çš„ä¸­ä½æ•°)|Hard|`å †` `æ’åº`|295|
|42|[]()||||
|43|[]()||||
|44|[]()||||
|45|[]()||||
|46|[]()||||
|47|[]()||||
|48|[]()||||
|49|[]()||||
|50|[]()||||
|51|[æ•°ç»„ä¸­çš„é€†åºå¯¹](#51-æ•°ç»„ä¸­çš„é€†åºå¯¹)|Hard|`å½’å¹¶ç®—æ³•` `é€†åºå¯¹`|~|
|52|[ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](#52-ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹)|Easy|`é“¾è¡¨`|160|
|53|[]()||||
|54|[]()||||
|55|[]()||||
|56|[]()||||
|57|[]()||||
|58|[]()||||
|59|[]()||||
|60|[]()||||
|61|[]()||||
|62|[]()||||
|63|[]()||||
|64|[]()||||
|65|[]()||||
|66|[]()||||
|67|[]()||||
|68|[]()||||
|69|[]()||||
|70|[]()||||
|71|[]()||||
|72|[]()||||
|73|[]()||||
|74|[]()||||
|75|[]()||||
|76|[]()||||
|77|[]()||||
|78|[]()||||
|79|[]()||||
|80|[]()||||


### 1.
### 2.
### 3.

### 4. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾
ğŸ¥‰åœ¨ä¸€ä¸ª n * m çš„äºŒç»´æ•°ç»„ä¸­ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»å·¦åˆ°å³é€’å¢çš„é¡ºåºæ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹é€’å¢çš„é¡ºåºæ’åºã€‚è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥è¿™æ ·çš„ä¸€ä¸ªäºŒç»´æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å«æœ‰è¯¥æ•´æ•°ã€‚
```
ç°æœ‰çŸ©é˜µmatrixå¦‚ä¸‹:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
ç»™å®š target = 5ï¼Œè¿”å› trueã€‚
ç»™å®š target = 20ï¼Œè¿”å› falseã€‚
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N+M)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
        int i = 0, j = matrix[0].size() - 1;
        //ğŸªä»çŸ©é˜µçš„å³ä¸Šè§’å¼€å§‹å¯»æ‰¾,targetç­‰äºå½“å‰å€¼æ—¶è¿”å›true,å¦åˆ™ç»§ç»­(å°äºæ—¶å¾€å·¦,å¤§äºæ—¶å¾€ä¸‹)
        while (i < matrix.size() && j >= 0) {
            if (target == matrix[i][j]) return true;
            target > matrix[i][j] ? i++ : j--;
        }
        return false;
    }
};
```

### 5.
### 6.
### 7.
### 8.

### 9. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—
ğŸ¥‰ç”¨ä¸¤ä¸ªæ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—ã€‚é˜Ÿåˆ—çš„å£°æ˜å¦‚ä¸‹ï¼Œè¯·å®ç°å®ƒçš„ä¸¤ä¸ªå‡½æ•° appendTail å’Œ deleteHead ï¼Œåˆ†åˆ«å®Œæˆåœ¨é˜Ÿåˆ—å°¾éƒ¨æ’å…¥æ•´æ•°å’Œåœ¨é˜Ÿåˆ—å¤´éƒ¨åˆ é™¤æ•´æ•°çš„åŠŸèƒ½ã€‚(è‹¥é˜Ÿåˆ—ä¸­æ²¡æœ‰å…ƒç´ ï¼ŒdeleteHead æ“ä½œè¿”å› -1 )
```
è¾“å…¥ï¼š["CQueue","appendTail","deleteHead","deleteHead"] [[],[3],[],[]]
è¾“å‡ºï¼š[null,null,3,-1]
```
---

æ ‡ç­¾: `æ ˆ` `é˜Ÿåˆ—`<br>
æ—¶é—´å¤æ‚åº¦:`O(1)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class CQueue {
public:
    CQueue() {}
    
    void appendTail(int value) {
        //ğŸªä½¿ç”¨åŒæ ˆå®ç°æ•°æ®çš„é€†åºå­˜æ”¾,ä»è€Œæ ˆé¡¶ä¸ºé˜Ÿåˆ—é¦–éƒ¨å…ƒç´ 
        stack<int> temp;
        while (!data.empty()) {
            temp.push(data.top());
            data.pop();
        }
        data.push(value);
        while (!temp.empty()) {
            data.push(temp.top());
            temp.pop();
        }
    }
    
    int deleteHead() {
        if (data.empty()) return -1;
        int top = data.top();
        data.pop();
        return top;
    }

private:
    stack<int> data;
};
```

### 10.

### 11.
### 12.
### 13.
### 14.
### 15.
### 16.
### 17.
### 18.
### 19.
### 20.

### 21.
### 22.
### 23.

### 24. åè½¬é“¾è¡¨
ğŸ¥‰å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œåè½¬è¯¥é“¾è¡¨å¹¶è¾“å‡ºåè½¬åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
```
è¾“å…¥: 1->2->3->4->5->NULL è¾“å‡º: 5->4->3->2->1->NULL
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *new_head = NULL;
        while (head) {
            ListNode *temp = head->next;
            head->next = new_head;
            new_head = head;
            head = temp;
        }
        return new_head;
    }
};
```

### 25.
### 26.
### 27.
### 28.

### 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ
ğŸ¥‰è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚
```
è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]] è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5]
è¾“å…¥ï¼šmatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] è¾“å‡ºï¼š[1,2,3,4,8,12,11,10,9,5,6,7]
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if (matrix.empty()) return res;
        int x1 = 0, y1 = 0;
        int x2 = matrix.size() - 1, y2 = matrix[0].size() - 1;

        while (x1 <= x2 && y1 <= y2) {
            int x = x1, y = y1;
            //ğŸªæ¯æ¬¡åªéå†æœ€å¤–è¾¹çš„ä¸€åœˆ,å•ç‹¬å¤„ç†åªæœ‰ä¸€è¡Œæˆ–ä¸€åˆ—çš„æƒ…å†µ
            if (x1 == x2) {
                while (y <= y2) res.push_back(matrix[x1][y++]);
            } else if (y1 == y2) {
                while (x <= x2) res.push_back(matrix[x++][y1]);
            } else {
                while (y != y2) res.push_back(matrix[x1][y++]);
                while (x != x2) res.push_back(matrix[x++][y2]);
                while (y != y1) res.push_back(matrix[x2][y--]);
                while (x != x1) res.push_back(matrix[x--][y1]);
            }
            x1++; y1++; x2--; y2--;
        }
        return res;
    }
};
```

### 30. åŒ…å«minå‡½æ•°çš„æ ˆ
ğŸ¥‰å®šä¹‰æ ˆçš„æ•°æ®ç»“æ„ï¼Œè¯·åœ¨è¯¥ç±»å‹ä¸­å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆçš„æœ€å°å…ƒç´ çš„ min å‡½æ•°åœ¨è¯¥æ ˆä¸­ï¼Œè°ƒç”¨ minã€push åŠ pop çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(1)ã€‚
```
push(x) â€”â€” å°†å…ƒç´  x æ¨å…¥æ ˆä¸­ã€‚
pop()Â â€”â€” åˆ é™¤æ ˆé¡¶çš„å…ƒç´ ã€‚
top()Â â€”â€” è·å–æ ˆé¡¶å…ƒç´ ã€‚
min() â€”â€” æ£€ç´¢æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚
```
---

æ ‡ç­¾: `æ ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(1)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {}
    
    void push(int x) {
        data.push(x);
        //ğŸªè‹¥æ–°æ•°æ®å°äºç­‰äºæœ€å°æ ˆçš„æ ˆé¡¶å…ƒç´ æ—¶,å°†å…¶å‹å…¥æœ€å°æ ˆ
        if (mins.empty() || x <= mins.top()) mins.push(x);
    }
    
    void pop() {
        //ğŸªå½“ä¸”ä»…å½“æœ€å°æ ˆæ ˆé¡¶å…ƒç´ ç­‰äºå¾…å¼¹å‡ºå…ƒç´ æ—¶æ‰å¼¹å‡º
        if (mins.top() == data.top()) mins.pop();
        data.pop();
    }
    
    int top() {
        return data.top();
    }
    
    int min() {
        return mins.top();
    }
private:
    stack<int> data;
    stack<int> mins;
};
```

### 31.
### 32.
### 33.
### 34.
### 35.
### 36.
### 37.
### 38.
### 39.
### 40.


### 41. æ•°æ®æµä¸­çš„ä¸­ä½æ•°
ğŸ…ï¸å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚<br>
è®¾è®¡ä¸€ä¸ªæ”¯æŒä»¥ä¸‹ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼š
```
void addNum(int num) - ä»æ•°æ®æµä¸­æ·»åŠ ä¸€ä¸ªæ•´æ•°åˆ°æ•°æ®ç»“æ„ä¸­ã€‚
double findMedian() - è¿”å›ç›®å‰æ‰€æœ‰å…ƒç´ çš„ä¸­ä½æ•°ã€‚
```
---

æ ‡ç­¾: `å †` `æ’åº`<br>
æ—¶é—´å¤æ‚åº¦:`O(logN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class MedianFinder {
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (less.empty()) {
            less.push(num);
            return;
        }
        //ğŸªå°†æ–°æ•°æ®å‹å…¥å †ä¸­(ä¸å¤§æ ¹å †çš„æ ¹å…ƒç´ æ¯”è¾ƒ),åŒæ—¶ç¡®ä¿å¤§æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ç­‰äºæˆ–å¤§äºå°æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ä¸€ä¸ª
        num <= less.top() ?  less.push(num) : great.push(num);
        if (less.size() > great.size() + 1) {
            great.push(less.top());
            less.pop();
        } else if (less.size() < great.size()) {
            less.push(great.top());
            great.pop();
        }
    }
    
    double findMedian() {
        return less.size() == great.size() ? (less.top() + great.top()) / 2.0 : less.top();
    }
    
private:
    //ğŸªåˆ©ç”¨ä¸€ä¸ªå¤§æ ¹å †(å­˜è¾ƒå°çš„æ•°)å’Œä¸€ä¸ªå°æ ¹å †(å­˜è¾ƒå¤§çš„æ•°)æ¥å­˜å‚¨æ•°æ®
    priority_queue<int, vector<int>, less<int>> less;
    priority_queue<int, vector<int>, greater<int>> great;
};
```
### 42.
### 43.
### 44.
### 45.
### 46.
### 47.
### 48.
### 49.
### 50.

### 51. æ•°ç»„ä¸­çš„é€†åºå¯¹
ğŸ…ï¸åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°ã€‚
```
è¾“å…¥: [7,5,6,4] è¾“å‡º: 5
```
---

æ ‡ç­¾: `å½’å¹¶ç®—æ³•` `é€†åºå¯¹`<br>
æ—¶é—´å¤æ‚åº¦:`O(NlogN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        if (nums.size() <= 1) return 0;
        int pairs = 0;
        mergeSort(nums, 0, nums.size() - 1, pairs);
        return pairs;
    }
    
    void mergeSort(vector<int> &nums, int left, int right, int &pairs) {
        if (left == right) return;
        int mid = left + (right - left) / 2;
        mergeSort(nums, left, mid, pairs);
        mergeSort(nums, mid + 1, right, pairs);
        mergeSubsequence(nums, left, mid, right, pairs);
        
        
    }
    
    void mergeSubsequence(vector<int> &nums, int left, int mid, int right, int &pairs) {
        vector<int> temp;
        int i = left, j = mid + 1;
        //ğŸªåŒæ—¶éå†å·¦å³ä¸¤ä¾§çš„å…ƒç´ ï¼Œå½“å·¦ä¾§å…ƒç´ å¤§äºå³ä¾§å…ƒç´ æ—¶å½¢æˆé€†åºå¯¹
        while (i <= mid && j <= right) {
            if (nums[i] > nums[j]) {
                temp.push_back(nums[j++]);
                //ğŸªå¯¹å·¦ä¾§å…ƒç´ æ¥è¯´,ä¸€æ—¦ä¸å³ä¾§æŸå…ƒç´ å½¢æˆé€†åºå¯¹ï¼Œåˆ™å…¶åé¢æ‰€æœ‰å…ƒç´ éƒ½å½¢æˆé€†åºå¯¹
                pairs += mid - i + 1;
            } else {
                temp.push_back(nums[i++]);
            }
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int k = 0; k != temp.size(); ++k) nums[left + k] = temp[k];
    }  
};
```

### 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹
ğŸ¥‰è¾“å…¥ä¸¤ä¸ªé“¾è¡¨ï¼Œæ‰¾å‡ºå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚<br>
æ³¨æ„ï¼šå¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null. åœ¨è¿”å›ç»“æœåï¼Œä¸¤ä¸ªé“¾è¡¨ä»é¡»ä¿æŒåŸæœ‰çš„ç»“æ„ã€‚å¯å‡å®šæ•´ä¸ªé“¾è¡¨ç»“æ„ä¸­æ²¡æœ‰å¾ªç¯ã€‚ç¨‹åºå°½é‡æ»¡è¶³ O(n) æ—¶é—´å¤æ‚åº¦ï¼Œä¸”ä»…ç”¨ O(1) å†…å­˜ã€‚
```
è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
è¾“å‡ºï¼šReference of the node with value = 8
è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,0,1,8,4,5]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *currA = headA, *currB = headB;
        int lenA = 0,lenB = 0;
        while (currA) {
            lenA++;
            currA = currA->next;
        }
        while (currB) {
            lenB++;
            currB = currB->next;
        }
        
        //ğŸªæ’é™¤è¾ƒé•¿é“¾è¡¨å¤šå‡ºçš„éƒ¨åˆ†ååŒæ—¶éå†ä¸¤æ¡é“¾è¡¨,ç»“ç‚¹ç›¸åŒæ—¶å³ä¸ºç›¸äº¤èŠ‚ç‚¹
        currA = headA; currB = headB;
        while (lenA > lenB) {
            currA = currA->next;
            lenA--;
        } 
        while (lenA < lenB) {
            currB = currB->next;
            lenB--;
        }
        while (currA != currB) {
            currA = currA->next;
            currB = currB->next;
        }
        return currA;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *currA = headA, *currB = headB;
        //ğŸªåˆ†åˆ«ä»ä¸¤ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹éå†,å½“é‡åˆ°ç©ºèŠ‚ç‚¹æ—¶,è·³åˆ°å¦ä¸€ä¸ªé“¾è¡¨ç»§ç»­éå†
        while (currA != currB) {
            currA = currA ? currA->next : headB;
            currB = currB ? currB->next : headA;
        }
        return currA;
    }
};
```

### 53.
### 54.
### 55.
### 56.
### 57.
### 58.
### 59.
### 60.

### 61.
### 62.
### 63.
### 64.
### 65.
### 66.
### 67.
### 68.
### 69.
### 70.

### 71.
### 72.
### 73.
### 74.
### 75.
### 76.
### 77.
### 78.
### 79.
### 80.
