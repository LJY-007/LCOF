## Table of Contents
|åºå·|é¢˜ç›®|éš¾åº¦|æ ‡ç­¾|LeetCode|
|:-:|:-|:-:|:-|:-:|
|1|[èµ‹å€¼è¿ç®—ç¬¦å‡½æ•°]()||||
|2|[]()||||
|3|[]()||||
|4|[äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾](#4-äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾)|Easy|`æ•°ç»„`|240|
|5|[]()||||
|6|[ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨](#6-ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨)|Easy|`é“¾è¡¨` `æ•°ç»„` `æ ˆ` `é€’å½’`|ï½|
|7|[é‡å»ºäºŒå‰æ ‘](#7-é‡å»ºäºŒå‰æ ‘)|Medium|`äºŒå‰æ ‘` `ä¸­åºéå†` `ååºéå†` `å“ˆå¸Œè¡¨` `é€’å½’`|105|
|8|[äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹](#8-äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹)|Easy|`äºŒå‰æ ‘`|ï½|
|9|[ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—](#9-ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—)|Easy|`æ ˆ` `é˜Ÿåˆ—`|232|
|10|[]()||||
|11|[]()||||
|12|[]()||||
|13|[]()||||
|14|[]()||||
|15|[]()||||
|16|[]()||||
|17|[]()||||
|18|[åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹](#18-åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹)|Easy|`é“¾è¡¨`|203|
|19|[]()||||
|20|[]()||||
|21|[]()||||
|22|[é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹](#22-é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹)|Easy|`é“¾è¡¨` `åŒæŒ‡é’ˆ`|ï½|
|23|[é“¾è¡¨ä¸­ç¯çš„å…¥å£èŠ‚ç‚¹](#23-é“¾è¡¨ä¸­ç¯çš„å…¥å£èŠ‚ç‚¹)|Medium|`é“¾è¡¨` `å¿«æ…¢æŒ‡é’ˆ`|142|
|24|[åè½¬é“¾è¡¨](#24-åè½¬é“¾è¡¨)|Easy|`é“¾è¡¨`|206|
|25|[]()||||
|26|[]()||||
|27|[]()||||
|28|[]()||||
|29|[é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](#29-é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ)|Easy|`æ•°ç»„`|54|
|30|[åŒ…å«minå‡½æ•°çš„æ ˆ](#30-åŒ…å«minå‡½æ•°çš„æ ˆ)|Easy|`æ ˆ`|155|
|31|[]()||||
|32-I|[ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ I](#32-I-ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘-I)|Medium|`äºŒå‰æ ‘` `BFS`|~|
|32-II|[ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II](#32-II-ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘-II)|Easy|`äºŒå‰æ ‘` `BFS`|102|
|32-III|[ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](#32-III-ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘-III)|Medium|`äºŒå‰æ ‘` `BFS` `åŒç«¯é˜Ÿåˆ—`|~|
|33|[]()||||
|34|[]()||||
|35|[å¤æ‚é“¾è¡¨çš„å¤åˆ¶](#35-å¤æ‚é“¾è¡¨çš„å¤åˆ¶)|Medium|`é“¾è¡¨` `å“ˆå¸Œè¡¨`|138|
|36|[]()||||
|37|[åºåˆ—åŒ–äºŒå‰æ ‘](#37-åºåˆ—åŒ–äºŒå‰æ ‘)|Hard|`äºŒå‰æ ‘` `BSF` `å­—ç¬¦ä¸²` `IOæµ`|297|
|38|[]()||||
|39|[]()||||
|40|[]()||||
|41|[æ•°æ®æµä¸­çš„ä¸­ä½æ•°](#41-æ•°æ®æµä¸­çš„ä¸­ä½æ•°)|Hard|`å †` `æ’åº`|295|
|42|[]()||||
|43|[]()||||
|44|[]()||||
|45|[]()||||
|46|[]()||||
|47|[]()||||
|48|[]()||||
|49|[]()||||
|50|[]()||||
|51|[æ•°ç»„ä¸­çš„é€†åºå¯¹](#51-æ•°ç»„ä¸­çš„é€†åºå¯¹)|Hard|`å½’å¹¶ç®—æ³•` `é€†åºå¯¹`|~|
|52|[ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](#52-ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹)|Easy|`é“¾è¡¨`|160|
|53|[]()||||
|54|[]()||||
|55-I|[äºŒå‰æ ‘çš„æ·±åº¦](#55-I-äºŒå‰æ ‘çš„æ·±åº¦)|Easy|`äºŒå‰æ ‘` `DFS` `BFS`|104|
|55-II|[å¹³è¡¡äºŒå‰æ ‘](#55-II-å¹³è¡¡äºŒå‰æ ‘)|Easy|`äºŒå‰æ ‘` `è‡ªé¡¶å‘ä¸‹` `è‡ªåº•å‘ä¸Š` `DFS`|110|
|56|[]()||||
|57|[]()||||
|58|[]()||||
|59|[]()||||
|60|[]()||||
|61|[]()||||
|62|[]()||||
|63|[]()||||
|64|[]()||||
|65|[]()||||
|66|[]()||||
|67|[]()||||
|68|[]()||||
|69|[]()||||
|70|[]()||||
|71|[]()||||
|72|[]()||||
|73|[]()||||
|74|[]()||||
|75|[]()||||
|76|[]()||||
|77|[]()||||
|78|[]()||||
|79|[]()||||
|80|[]()||||


### 1.
### 2.

### 3. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—
ğŸ¥‰æ‰¾å‡ºæ•°ç»„ä¸­é‡å¤çš„æ•°å­—ã€‚
åœ¨ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ nums é‡Œçš„æ‰€æœ‰æ•°å­—éƒ½åœ¨ 0ï½n-1 çš„èŒƒå›´å†…ã€‚æ•°ç»„ä¸­æŸäº›æ•°å­—æ˜¯é‡å¤çš„ï¼Œä½†ä¸çŸ¥é“æœ‰å‡ ä¸ªæ•°å­—é‡å¤äº†ï¼Œä¹Ÿä¸çŸ¥é“æ¯ä¸ªæ•°å­—é‡å¤äº†å‡ æ¬¡ã€‚è¯·æ‰¾å‡ºæ•°ç»„ä¸­ä»»æ„ä¸€ä¸ªé‡å¤çš„æ•°å­—ã€‚
```
è¾“å…¥ï¼š[2, 3, 1, 0, 2, 5, 3] è¾“å‡ºï¼š2 æˆ– 3 
```
---

æ ‡ç­¾: `æ•°ç»„` `å“ˆå¸Œè¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, int> counter;
        for (int i : nums) {
            if (counter.find(i) != counter.end()) return i;
            counter[i]++;
        }
        return -1;
    }
};
```

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for (int i = 0; i != nums.size(); ++i) {
            //ğŸªå°†æ•°ç»„çš„ä¸‹æ ‡å’Œæ•°æ®å…ƒç´ çš„å€¼å¯¹åº”
            if (nums[i] != i) {
                if (nums[nums[i]] == nums[i]) return nums[i];
                swap(nums[i], nums[nums[i]]);
                i--;
            }
        }
        return -1;
    }
};
```


### 4. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾
ğŸ¥‰åœ¨ä¸€ä¸ª n * m çš„äºŒç»´æ•°ç»„ä¸­ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»å·¦åˆ°å³é€’å¢çš„é¡ºåºæ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹é€’å¢çš„é¡ºåºæ’åºã€‚è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥è¿™æ ·çš„ä¸€ä¸ªäºŒç»´æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å«æœ‰è¯¥æ•´æ•°ã€‚
```
ç°æœ‰çŸ©é˜µmatrixå¦‚ä¸‹:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
ç»™å®š target = 5ï¼Œè¿”å› trueã€‚
ç»™å®š target = 20ï¼Œè¿”å› falseã€‚
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N+M)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
        int i = 0, j = matrix[0].size() - 1;
        //ğŸªä»çŸ©é˜µçš„å³ä¸Šè§’å¼€å§‹å¯»æ‰¾,targetç­‰äºå½“å‰å€¼æ—¶è¿”å›true,å¦åˆ™ç»§ç»­(å°äºæ—¶å¾€å·¦,å¤§äºæ—¶å¾€ä¸‹)
        while (i < matrix.size() && j >= 0) {
            if (target == matrix[i][j]) return true;
            target > matrix[i][j] ? i++ : j--;
        }
        return false;
    }
};
```

### 5.

### 6. ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨
ğŸ¥‰è¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œä»å°¾åˆ°å¤´åè¿‡æ¥è¿”å›æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆç”¨æ•°ç»„è¿”å›ï¼‰ã€‚
```
è¾“å…¥ï¼šhead = [1,3,2] è¾“å‡ºï¼š[2,3,1]
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        ListNode *new_head = NULL;
        //ğŸªåè½¬é“¾è¡¨åå†æ¬¡éå†å¹¶è¾“å‡ºval(ä¿®æ”¹äº†é“¾è¡¨ç»“æ„)
        while (head) {
            ListNode *temp = head->next;
            head->next = new_head;
            new_head = head;
            head = temp;
        }
        vector<int> res;
        while (new_head) {
            res.push_back(new_head->val);
            new_head = new_head->next;
        }
        return res;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨` `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        ListNode *curr = head;
        int len = 0;
        //ğŸªéå†é“¾è¡¨å»ºç«‹ç­‰é•¿çš„æ•°ç»„,å†æ¬¡éå†è¾“å‡ºå¯¹åº”(ç›¸å)ä½ç½®çš„å€¼
        while (curr) {
            len++;
            curr = curr->next;
        }
        vector<int> res(len);
        curr = head;
        while (curr) {
            res[--len] = curr->val;
            curr = curr->next;
        }
        return res;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨` `æ ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        //ğŸªä½¿ç”¨æ ˆç»“æ„éå†å‹å…¥é“¾è¡¨ç»“ç‚¹åä¾æ¬¡å¼¹å‡ºå¹¶æ‰“å°
        stack<ListNode*> nodes;
        while (head) {
            nodes.push(head);
            head = head->next;
        }
        vector<int> res;
        while (!nodes.empty()) {
            res.push_back(nodes.top()->val);
            nodes.pop();
        }
        return res;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨` `é€’å½’`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        if (!head) return res;
        //ğŸªé€’å½’æ–¹æ³•(æœ¬è´¨ä¸æ ˆç›¸åŒ)å®ç°é“¾è¡¨çš„æ‰“å°
        reversePrint(head->next);
        res.push_back(head->val);
        return res;
    }

private:
    vector<int> res;
};
```

### 7. é‡å»ºäºŒå‰æ ‘
ğŸ¥ˆè¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚
```
ç»™å‡º: å‰åºéå† preorder =Â [3,9,20,15,7] ä¸­åºéå† inorder = [9,3,15,20,7]
è¿”å›äºŒå‰æ ‘:

    3
   / \
  9  20
    /  \
   15   7
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `ä¸­åºéå†` `ååºéå†` `å“ˆå¸Œè¡¨` `é€’å½’`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        //ğŸªç”¨å“ˆå¸Œè¡¨è®°å½•ä¸­åºéå†çš„å€¼ä¸ä¸‹æ ‡,ä¾¿äºåœ¨é€’å½’ä¸­å¿«é€ŸæŸ¥æ‰¾åˆ°æ ¹çš„ä½ç½®
        for (int i = 0; i != inorder.size(); ++i) indexs[inorder[i]] = i;
        return recursiveBuild(preorder, 0, 0, inorder.size() - 1);
    }

    TreeNode* recursiveBuild(const vector<int>& preorder, int pre_root, int in_left, int in_right) {
        if (in_left > in_right) return NULL;
        //ğŸªå»ºç«‹æ ¹ç»“ç‚¹,å¹¶ç¡®å®šå·¦å³å­æ ‘åœ¨å‰åºéå†ä¸ä¸­åºéå†ä¸­çš„åˆ†å‰²,ä¹‹åè¿æ¥æ ¹ç»“ç‚¹ä¸å·¦å³å­æ ‘
        TreeNode *root = new TreeNode(preorder[pre_root]);
        int in_root = indexs[preorder[pre_root]];
        root->left = recursiveBuild(preorder, pre_root + 1, in_left, in_root - 1);
        root->right = recursiveBuild(preorder, pre_root + in_root - in_left + 1, in_root + 1, in_right);
        return root;
    }

private:
    unordered_map<int, int> indexs;
};
```

### 8. äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹
ğŸ¥‰ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œå…¶ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œè¯·æ‰¾å‡ºä¸­åºéå†é¡ºåºçš„ä¸‹ä¸€ä¸ªç»“ç‚¹å¹¶ä¸”è¿”å›ã€‚æ³¨æ„ï¼Œæ ‘ä¸­çš„ç»“ç‚¹ä¸ä»…åŒ…å«å·¦å³å­ç»“ç‚¹ï¼ŒåŒæ—¶åŒ…å«æŒ‡å‘çˆ¶ç»“ç‚¹çš„æŒ‡é’ˆã€‚

---

æ ‡ç­¾: `äºŒå‰æ ‘` `ä¸­åºéå†`<br>
æ—¶é—´å¤æ‚åº¦:`O(\)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        if (!pNode) return NULL;
        //ğŸªè‹¥ç»“ç‚¹æœ‰å³å­æ ‘,é‚£ä¹ˆå®ƒçš„å³å­æ ‘ä¸­çš„æœ€å·¦å­ç»“ç‚¹å³ä¸ºä¸‹ä¸€ä¸ªç»“ç‚¹
        if (pNode->right) {
            pNode = pNode->right;
            while (pNode->left) pNode = pNode->left;
            return pNode;
        } else {
            /*ğŸªå½“å‰ç»“ç‚¹è‹¥ä¸ºçˆ¶ç»“ç‚¹çš„å·¦å­ç»“ç‚¹,åˆ™çˆ¶ç»“ç‚¹å³ä¸ºä¸‹ä¸€ä¸ªç»“ç‚¹;
                è‹¥å½“å‰ç»“ç‚¹ä¸ºçˆ¶ç»“ç‚¹çš„å³å­ç»“ç‚¹,åˆ™ä¸æ–­å¾€ä¸Šè¿­ä»£ç›´åˆ°æ‰¾åˆ°æ˜¯å…¶çˆ¶ç»“ç‚¹çš„å·¦å­ç»“ç‚¹çš„ç»“ç‚¹(å…¶çˆ¶ç»“ç‚¹ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹)*/
            while (pNode->parent && pNode->parent->right == pNode) pNode = pNode->parent;
            return pNode->parent;
        }
    }
};
```

### 9. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—
ğŸ¥‰ç”¨ä¸¤ä¸ªæ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—ã€‚é˜Ÿåˆ—çš„å£°æ˜å¦‚ä¸‹ï¼Œè¯·å®ç°å®ƒçš„ä¸¤ä¸ªå‡½æ•° appendTail å’Œ deleteHead ï¼Œåˆ†åˆ«å®Œæˆåœ¨é˜Ÿåˆ—å°¾éƒ¨æ’å…¥æ•´æ•°å’Œåœ¨é˜Ÿåˆ—å¤´éƒ¨åˆ é™¤æ•´æ•°çš„åŠŸèƒ½ã€‚(è‹¥é˜Ÿåˆ—ä¸­æ²¡æœ‰å…ƒç´ ï¼ŒdeleteHead æ“ä½œè¿”å› -1 )
```
è¾“å…¥ï¼š["CQueue","appendTail","deleteHead","deleteHead"] [[],[3],[],[]]
è¾“å‡ºï¼š[null,null,3,-1]
```
---

æ ‡ç­¾: `æ ˆ` `é˜Ÿåˆ—`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class CQueue {
public:
    CQueue() {}
    
    void appendTail(int value) {
        //ğŸªä½¿ç”¨åŒæ ˆå®ç°æ•°æ®çš„é€†åºå­˜æ”¾,ä»è€Œæ ˆé¡¶ä¸ºé˜Ÿåˆ—é¦–éƒ¨å…ƒç´ 
        stack<int> temp;
        while (!data.empty()) {
            temp.push(data.top());
            data.pop();
        }
        data.push(value);
        while (!temp.empty()) {
            data.push(temp.top());
            temp.pop();
        }
    }
    
    int deleteHead() {
        if (data.empty()) return -1;
        int top = data.top();
        data.pop();
        return top;
    }

private:
    stack<int> data;
};
```

### 10.

### 11.
### 12.
### 13.
### 14.
### 15.
### 16.
### 17.

### 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹
ğŸ¥‰ç»™å®šå•å‘é“¾è¡¨çš„å¤´æŒ‡é’ˆå’Œä¸€ä¸ªè¦åˆ é™¤çš„èŠ‚ç‚¹çš„å€¼ï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°åˆ é™¤è¯¥èŠ‚ç‚¹ã€‚è¿”å›åˆ é™¤åçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
```
è¾“å…¥: head = [4,5,1,9], val = 5 è¾“å‡º: [4,1,9]
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode pre_node(0); //æ–°å»ºå¤´ç»“ç‚¹ä¾¿äºå¯¹ç¬¬ä¸€ä¸ªç»“ç‚¹çš„æ“ä½œ
        ListNode *curr = &pre_node;
        curr->next = head;
        while (curr->next) {
            if (curr->next->val == val) {
                curr->next = curr->next->next;
                break;
            }
            curr = curr->next;
        }
        return pre_node.next;
    }
};
```

### 19.
### 20.

### 21.

### 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹
ğŸ¥‰è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ã€‚ä¸ºäº†ç¬¦åˆå¤§å¤šæ•°äººçš„ä¹ æƒ¯ï¼Œæœ¬é¢˜ä»1å¼€å§‹è®¡æ•°ï¼Œå³é“¾è¡¨çš„å°¾èŠ‚ç‚¹æ˜¯å€’æ•°ç¬¬1ä¸ªèŠ‚ç‚¹ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªé“¾è¡¨æœ‰6ä¸ªèŠ‚ç‚¹ï¼Œä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œå®ƒä»¬çš„å€¼ä¾æ¬¡æ˜¯1ã€2ã€3ã€4ã€5ã€6ã€‚è¿™ä¸ªé“¾è¡¨çš„å€’æ•°ç¬¬3ä¸ªèŠ‚ç‚¹æ˜¯å€¼ä¸º4çš„èŠ‚ç‚¹ã€‚
```
ç»™å®šä¸€ä¸ªé“¾è¡¨: 1->2->3->4->5, å’Œ k = 2.
è¿”å›é“¾è¡¨ 4->5.
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        if (k <= 0) return NULL;
        //ğŸªéå†é“¾è¡¨å¾—åˆ°å€’æ•°ç¬¬kä¸ªç»“ç‚¹çš„é¡ºåºæ•°
        ListNode *curr = head;
        int len = 0;
        while (curr) {
            len++;
            curr = curr->next;
        }
        if (len < k) return NULL;
        curr = head;
        for (int i = len - k; i != 0; i--) curr = curr->next;
        return curr;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨` `åŒæŒ‡é’ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *fast = head, *slow = head;
        if (k <= 0) return NULL;
        //ğŸªç»´æŒåŒæŒ‡é’ˆè·¨åº¦ä¸ºkä¸ªç»“ç‚¹å¹¶åŒæ—¶å‘åéå†,å½“å¿«æŒ‡é’ˆåˆ°è¾¾æœ€åä¸€ä¸ªç»“ç‚¹æ—¶è¿”å›æ…¢æŒ‡é’ˆ
        while (--k) {
            fast = fast->next;
            if (!fast) return NULL;
        }
        while (fast->next) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

### 23. é“¾è¡¨ä¸­ç¯çš„å…¥å£èŠ‚ç‚¹
ğŸ¥ˆç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚
ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚ å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚
è¯´æ˜ï¼šä¸å…è®¸ä¿®æ”¹ç»™å®šçš„é“¾è¡¨ã€‚
```
è¾“å…¥ï¼šhead = [3,2,0,-4], pos = 1 è¾“å‡ºï¼štail connects to node index 1
è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚
è¾“å…¥ï¼šhead = [1], pos = -1 è¾“å‡ºï¼šno cycle
è§£é‡Šï¼šé“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚
```
---

æ ‡ç­¾: `é“¾è¡¨` `å¿«æ…¢æŒ‡é’ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        //ğŸªåˆ¤æ–­æ˜¯å¦æœ‰ç¯å¹¶ç¡®å®šå¿«æ…¢æŒ‡é’ˆç›¸é‡çš„ä½ç½®
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) break;
        }
        if (!fast || !fast->next) return NULL;
        //ğŸªå¿«æ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡çš„ç»“ç‚¹ä¸å…¥ç¯ç»“ç‚¹çš„è·ç¦»ç­‰äºå¤´ç»“ç‚¹ä¸å…¥ç¯ç»“ç‚¹çš„è·ç¦»
        fast = head;
        while (1) {
            if (fast == slow) return fast;
            fast = fast->next;
            slow = slow->next;
        }
    }
};
```

### 24. åè½¬é“¾è¡¨
ğŸ¥‰å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œåè½¬è¯¥é“¾è¡¨å¹¶è¾“å‡ºåè½¬åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
```
è¾“å…¥: 1->2->3->4->5->NULL è¾“å‡º: 5->4->3->2->1->NULL
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *new_head = NULL;
        while (head) {
            ListNode *temp = head->next;
            head->next = new_head;
            new_head = head;
            head = temp;
        }
        return new_head;
    }
};
```

### 25.
### 26.
### 27.
### 28.

### 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ
ğŸ¥‰è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚
```
è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]] è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5]
è¾“å…¥ï¼šmatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] è¾“å‡ºï¼š[1,2,3,4,8,12,11,10,9,5,6,7]
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if (matrix.empty()) return res;
        int x1 = 0, y1 = 0;
        int x2 = matrix.size() - 1, y2 = matrix[0].size() - 1;

        while (x1 <= x2 && y1 <= y2) {
            int x = x1, y = y1;
            //ğŸªæ¯æ¬¡åªéå†æœ€å¤–è¾¹çš„ä¸€åœˆ,å•ç‹¬å¤„ç†åªæœ‰ä¸€è¡Œæˆ–ä¸€åˆ—çš„æƒ…å†µ
            if (x1 == x2) {
                while (y <= y2) res.push_back(matrix[x1][y++]);
            } else if (y1 == y2) {
                while (x <= x2) res.push_back(matrix[x++][y1]);
            } else {
                while (y != y2) res.push_back(matrix[x1][y++]);
                while (x != x2) res.push_back(matrix[x++][y2]);
                while (y != y1) res.push_back(matrix[x2][y--]);
                while (x != x1) res.push_back(matrix[x--][y1]);
            }
            x1++; y1++; x2--; y2--;
        }
        return res;
    }
};
```

### 30. åŒ…å«minå‡½æ•°çš„æ ˆ
ğŸ¥‰å®šä¹‰æ ˆçš„æ•°æ®ç»“æ„ï¼Œè¯·åœ¨è¯¥ç±»å‹ä¸­å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆçš„æœ€å°å…ƒç´ çš„ min å‡½æ•°åœ¨è¯¥æ ˆä¸­ï¼Œè°ƒç”¨ minã€push åŠ pop çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(1)ã€‚
```
push(x) â€”â€” å°†å…ƒç´  x æ¨å…¥æ ˆä¸­ã€‚
pop()Â â€”â€” åˆ é™¤æ ˆé¡¶çš„å…ƒç´ ã€‚
top()Â â€”â€” è·å–æ ˆé¡¶å…ƒç´ ã€‚
min() â€”â€” æ£€ç´¢æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚
```
---

æ ‡ç­¾: `æ ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(1)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {}
    
    void push(int x) {
        data.push(x);
        //ğŸªè‹¥æ–°æ•°æ®å°äºç­‰äºæœ€å°æ ˆçš„æ ˆé¡¶å…ƒç´ æ—¶,å°†å…¶å‹å…¥æœ€å°æ ˆ
        if (mins.empty() || x <= mins.top()) mins.push(x);
    }
    
    void pop() {
        //ğŸªå½“ä¸”ä»…å½“æœ€å°æ ˆæ ˆé¡¶å…ƒç´ ç­‰äºå¾…å¼¹å‡ºå…ƒç´ æ—¶æ‰å¼¹å‡º
        if (mins.top() == data.top()) mins.pop();
        data.pop();
    }
    
    int top() {
        return data.top();
    }
    
    int min() {
        return mins.top();
    }
private:
    stack<int> data;
    stack<int> mins;
};
```
### 31.

### 32-I. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ I
ğŸ¥ˆä»ä¸Šåˆ°ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ã€‚
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7] 
    3
   / \
  9  20
    /  \
   15   7
è¿”å›: [3,9,20,15,7]
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `BFS`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res; 
        if (!root) return res;
        //ğŸªåˆ©ç”¨é˜Ÿåˆ—FIFOçš„ç‰¹ç‚¹å¯¹æ¯ä¸€å±‚è¿›è¡Œè¿­ä»£è¾“å‡º
        queue<TreeNode*> nodes;
        nodes.push(root);
        while (!nodes.empty()) {
            res.push_back(nodes.front()->val);
            if (nodes.front()->left) nodes.push(nodes.front()->left);
            if (nodes.front()->right) nodes.push(nodes.front()->right);
            nodes.pop();
        }
        return res;
    }
};
```

### 32-II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II
ğŸ¥‰ä»ä¸Šåˆ°ä¸‹æŒ‰å±‚æ‰“å°äºŒå‰æ ‘ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œæ¯ä¸€å±‚æ‰“å°åˆ°ä¸€è¡Œã€‚
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7] 
    3
   / \
  9  20
    /  \
   15   7
è¿”å›å…¶å±‚æ¬¡éå†ç»“æœ:
[
  [3],
  [9,20],
  [15,7]
]
```

---

æ ‡ç­¾: `äºŒå‰æ ‘` `BFS`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        //ğŸªåˆ©ç”¨é˜Ÿåˆ—FIFOçš„ç‰¹ç‚¹å¯¹æ¯ä¸€å±‚è¿›è¡Œè¿­ä»£è¾“å‡º
        queue<TreeNode*> nodes;
        nodes.push(root);
        while (!nodes.empty()) {
            int len = nodes.size();
            vector<int> temp;
            while (len--) {
                temp.push_back(nodes.front()->val);
                if (nodes.front()->left) nodes.push(nodes.front()->left);
                if (nodes.front()->right) nodes.push(nodes.front()->right);
                nodes.pop();
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

### 32-III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III
ğŸ¥ˆè¯·å®ç°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»å³åˆ°å·¦çš„é¡ºåºæ‰“å°ï¼Œç¬¬ä¸‰è¡Œå†æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œå…¶ä»–è¡Œä»¥æ­¤ç±»æ¨ã€‚
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
è¿”å›å…¶å±‚æ¬¡éå†ç»“æœ: 
[
  [3],
  [20,9],
  [15,7]
]
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `BFS` `åŒç«¯é˜Ÿåˆ—`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        //ğŸªä½¿ç”¨åŒç«¯é˜Ÿåˆ—åœ¨æ¯ä¸€å±‚çš„è¿­ä»£é—´æ”¹å˜ä¸€æ¬¡å¼¹å‡ºå’Œå‹å…¥çš„å¤´å°¾é¡ºåº
        deque<TreeNode*> nodes;
        nodes.push_back(root);
        int layer = 0;
        while (!nodes.empty()) {
            layer++;
            int len = nodes.size();
            vector<int> temp;
            if (layer & 1) {
                while (len--) {
                    temp.push_back(nodes.front()->val);
                    if (nodes.front()->left) nodes.push_back(nodes.front()->left);
                    if (nodes.front()->right) nodes.push_back(nodes.front()->right);
                    nodes.pop_front();
                }
            } else {
                while (len--) {
                    temp.push_back(nodes.back()->val);
                    if (nodes.back()->right) nodes.push_front(nodes.back()->right);
                    if (nodes.back()->left) nodes.push_front(nodes.back()->left);
                    nodes.pop_back();
                }
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

æ ‡ç­¾: `äºŒå‰æ ‘` `BFS` `é˜Ÿåˆ—` `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        //ğŸªä½¿ç”¨é˜Ÿåˆ—å¯¹æ¯ä¸€å±‚è¿›è¡Œè¿­ä»£è¾“å‡º,å½“é‡åˆ°å¶æ•°å±‚æ—¶åè½¬è¯¥å±‚çš„æ•°ç»„
        queue<TreeNode*> nodes;
        nodes.push(root);
        int layer = 0;
        while (!nodes.empty()) {
            layer++;
            int len = nodes.size();
            vector<int> temp;
            while (len--) {
                temp.push_back(nodes.front()->val);
                if (nodes.front()->left) nodes.push(nodes.front()->left);
                if (nodes.front()->right) nodes.push(nodes.front()->right);
                nodes.pop();
            }
            if (!(layer & 1)) reverse(temp.begin(), temp.end());
            res.push_back(temp);
        }
        return res;
    }
};
```

### 33.
### 34.
### 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶
ğŸ¥ˆè¯·å®ç° copyRandomList å‡½æ•°ï¼Œå¤åˆ¶ä¸€ä¸ªå¤æ‚é“¾è¡¨ã€‚åœ¨å¤æ‚é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†æœ‰ä¸€ä¸ª next æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰ä¸€ä¸ª random æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„èŠ‚ç‚¹æˆ–è€… nullã€‚
```
è¾“å…¥ï¼šhead = [[7,null],[13,0],[11,4],[10,2],[1,0]]
è¾“å‡ºï¼š[[7,null],[13,0],[11,4],[10,2],[1,0]]
```
---

æ ‡ç­¾: `é“¾è¡¨` `å“ˆå¸Œè¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        //ğŸªåˆ©ç”¨å“ˆå¸Œè¡¨å»ºç«‹å¤åˆ¶é“¾è¡¨ä¸åŸé“¾è¡¨çš„å¯¹åº”å…³ç³»
        unordered_map<Node*, Node*> nodes;
        Node *new_head = head;
        while (head) {
            nodes[head] = new Node(head->val);
            head = head->next;
        }
        //ğŸªä¾æ¬¡éå†å°†æ¯ä¸ªç»“ç‚¹çš„nextä¸randomæŒ‡é’ˆå¯¹åº”
        head = new_head;
        while (head) {
            nodes[head]->next = nodes[head->next];
            nodes[head]->random = nodes[head->random];
            head = head->next;
        }
        new_head = nodes[new_head];
        return new_head;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return head;
        Node *new_head = head;
        //ğŸªéå†æ•´ä¸ªé“¾è¡¨,åœ¨æ¯ä¸ªç»“ç‚¹çš„åé¢æ–°å»ºå¯¹åº”çš„å¤åˆ¶ç»“ç‚¹
        while (head) {
            Node *temp = head->next;
            head->next = new Node(head->val);
            head->next->next = temp;
            head = temp;
        }
        //ğŸªéå†é“¾è¡¨å®Œæˆå†…éƒ¨æŒ‡é’ˆå…³ç³»çš„å¤åˆ¶(æ¯ä¸¤ä¸ªç»“ç‚¹ä¸€ç»„,nextèŠ‚ç‚¹çš„randomæŒ‡å‘å½“å‰èŠ‚ç‚¹çš„randomçš„next)
        head = new_head;
        while (head) {
            if (head->random) head->next->random = head->random->next; //æ³¨æ„randomä¸ºç©ºçš„æƒ…å†µ
            head = head->next->next;
        }
        //ğŸªå¤åˆ¶å®Œæˆåè¦åˆ†ç¦»é“¾è¡¨,ä¸å½±å“åŸé“¾è¡¨ç»“æ„
        head = new_head;
        new_head = new_head->next;
        while (head) {
            Node *temp = head->next->next;
            if (temp) head->next->next = temp->next; //æ³¨æ„æœ€åä¸€ä¸ªä¸¤ä¸ªç»“ç‚¹çš„åˆ†ç¦»
            head->next = temp;
            head = temp;
        }
        return new_head;
    }
};
```

### 36.

### 37. åºåˆ—åŒ–äºŒå‰æ ‘
ğŸ…ï¸è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚
```
ä½ å¯ä»¥å°†ä»¥ä¸‹äºŒå‰æ ‘:

    1
   / \
  2   3
     / \
    4   5
åºåˆ—åŒ–ä¸º: "[1,2,3,null,null,4,5]"
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `BSF` `å­—ç¬¦ä¸²`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Codec {
public:
    string serialize(TreeNode* root) {
        //ğŸªBFSå±‚åºéå†äºŒå‰æ ‘,ä»¥å­—ç¬¦ä¸²çš„å½¢å¼å­˜å‚¨ç»“ç‚¹çš„å€¼(ç©ºèŠ‚ç‚¹çš„å€¼ä¸º"null",ä»¥','åˆ†å‰²)
        string res;
        queue<TreeNode*> nodes;
        nodes.push(root);
        while (!nodes.empty()) {
            if (nodes.front()) {
                res += to_string(nodes.front()->val) + ',';
                nodes.push(nodes.front()->left);
                nodes.push(nodes.front()->right);
            } else {
                res += "null,";
            }
            nodes.pop();
        }
        return res;
    }
    
    TreeNode* deserialize(string data) {
        //ğŸªå°†å­—ç¬¦ä¸²ä»¥ç‰¹å®šç¬¦å·ä¸ºç•Œåˆ†å‰²,å¹¶ä»¥æ­¤å»ºç«‹å¯¹åº”çš„ç»“ç‚¹(ç”¨æŒ‡é’ˆæ•°ç»„å­˜å‚¨)
        vector<TreeNode*> nodes;
        string temp = "";
        for (auto c : data) {
            if (c == ',') {
                if (temp == "null") {
                    nodes.push_back(NULL);
                } else {
                    nodes.push_back(new TreeNode(stoi(temp)));
                }
                temp = "";
            } else {
                temp += c;
            }
        }
        
        //ğŸªä½¿ç”¨i,jä¸¤ä¸ªä¸‹æ ‡åˆ†åˆ«è¡¨ç¤ºå½“å‰ç»“ç‚¹ä¸å…¶å·¦å³å­ç»“ç‚¹(å½“iæŒ‡å‘ç©ºç»“ç‚¹æ—¶,jä¸å˜)çš„ä½ç½®
        for (int i = 0, j = 1; j != nodes.size(); ++i) {
            if (nodes[i]) {
                nodes[i]->left = nodes[j++];
                nodes[i]->right = nodes[j++];
            } 
        }
        return nodes[0];
    }
};
```

æ ‡ç­¾: `äºŒå‰æ ‘` `BSF` `IOæµ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Codec {
public:
    string serialize(TreeNode* root) {
        //ğŸªBFSå±‚åºéå†äºŒå‰æ ‘,ä»¥è¾“å‡ºæµçš„å½¢å¼å­˜å‚¨ç»“ç‚¹çš„å€¼(ç©ºèŠ‚ç‚¹çš„å€¼ä¸º"null",ä»¥' 'åˆ†å‰²)
        ostringstream output;
        queue<TreeNode*> nodes;
        nodes.push(root);
        while (!nodes.empty()) {
            if (nodes.front()) {
                output << nodes.front()->val << ' '; //å·§å¦™è¿ç”¨è¾“å‡ºæµé¿å…äº†ç±»å‹è½¬æ¢
                nodes.push(nodes.front()->left);
                nodes.push(nodes.front()->right);
            } else {
                output << "null ";
            }
            nodes.pop();
        }
        return output.str();
    }

    TreeNode* deserialize(string data) {
        //ğŸªæ¯æ¬¡ä»è¾“å…¥æµè¯»å–å­—ç¬¦ä¸²(ä»¥' 'åˆ†å‰²),å¹¶ä»¥æ­¤å»ºç«‹å¯¹åº”çš„ç»“ç‚¹(ç”¨æŒ‡é’ˆæ•°ç»„å­˜å‚¨)
        istringstream input(data);
        string val;
        vector<TreeNode*> nodes;
        while (input >> val) {
            if (val == "null") {
                nodes.push_back(NULL);
            } else {
                nodes.push_back(new TreeNode(stoi(val)));
            }
        }
        
        //ğŸªä½¿ç”¨i,jä¸¤ä¸ªä¸‹æ ‡åˆ†åˆ«è¡¨ç¤ºå½“å‰ç»“ç‚¹ä¸å…¶å·¦å³å­ç»“ç‚¹(å½“iæŒ‡å‘ç©ºç»“ç‚¹æ—¶,jä¸å˜)çš„ä½ç½®
        for (int i = 0, j = 1; j != nodes.size(); ++i) {
            if (nodes[i]) {
                nodes[i]->left = nodes[j++];
                nodes[i]->right = nodes[j++];
            } 
        }
        return nodes[0];
    }
};
```

### 38.
### 39.
### 40.


### 41. æ•°æ®æµä¸­çš„ä¸­ä½æ•°
ğŸ…ï¸å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚<br>
è®¾è®¡ä¸€ä¸ªæ”¯æŒä»¥ä¸‹ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼š
```
void addNum(int num) - ä»æ•°æ®æµä¸­æ·»åŠ ä¸€ä¸ªæ•´æ•°åˆ°æ•°æ®ç»“æ„ä¸­ã€‚
double findMedian() - è¿”å›ç›®å‰æ‰€æœ‰å…ƒç´ çš„ä¸­ä½æ•°ã€‚
```
---

æ ‡ç­¾: `å †` `æ’åº`<br>
æ—¶é—´å¤æ‚åº¦:`O(logN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class MedianFinder {
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (less.empty()) {
            less.push(num);
            return;
        }
        //ğŸªå°†æ–°æ•°æ®å‹å…¥å †ä¸­(ä¸å¤§æ ¹å †çš„æ ¹å…ƒç´ æ¯”è¾ƒ),åŒæ—¶ç¡®ä¿å¤§æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ç­‰äºæˆ–å¤§äºå°æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ä¸€ä¸ª
        num <= less.top() ?  less.push(num) : great.push(num);
        if (less.size() > great.size() + 1) {
            great.push(less.top());
            less.pop();
        } else if (less.size() < great.size()) {
            less.push(great.top());
            great.pop();
        }
    }
    
    double findMedian() {
        return less.size() == great.size() ? (less.top() + great.top()) / 2.0 : less.top();
    }
    
private:
    //ğŸªåˆ©ç”¨ä¸€ä¸ªå¤§æ ¹å †(å­˜è¾ƒå°çš„æ•°)å’Œä¸€ä¸ªå°æ ¹å †(å­˜è¾ƒå¤§çš„æ•°)æ¥å­˜å‚¨æ•°æ®
    priority_queue<int, vector<int>, less<int>> less;
    priority_queue<int, vector<int>, greater<int>> great;
};
```
### 42.
### 43.
### 44.
### 45.
### 46.
### 47.
### 48.
### 49.
### 50.

### 51. æ•°ç»„ä¸­çš„é€†åºå¯¹
ğŸ…ï¸åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°ã€‚
```
è¾“å…¥: [7,5,6,4] è¾“å‡º: 5
```
---

æ ‡ç­¾: `å½’å¹¶ç®—æ³•` `é€†åºå¯¹`<br>
æ—¶é—´å¤æ‚åº¦:`O(NlogN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        if (nums.size() <= 1) return 0;
        int pairs = 0;
        mergeSort(nums, 0, nums.size() - 1, pairs);
        return pairs;
    }
    
    void mergeSort(vector<int> &nums, int left, int right, int &pairs) {
        if (left == right) return;
        int mid = left + (right - left) / 2;
        mergeSort(nums, left, mid, pairs);
        mergeSort(nums, mid + 1, right, pairs);
        mergeSubsequence(nums, left, mid, right, pairs);
        
        
    }
    
    void mergeSubsequence(vector<int> &nums, int left, int mid, int right, int &pairs) {
        vector<int> temp;
        int i = left, j = mid + 1;
        //ğŸªåŒæ—¶éå†å·¦å³ä¸¤ä¾§çš„å…ƒç´ ï¼Œå½“å·¦ä¾§å…ƒç´ å¤§äºå³ä¾§å…ƒç´ æ—¶å½¢æˆé€†åºå¯¹
        while (i <= mid && j <= right) {
            if (nums[i] > nums[j]) {
                temp.push_back(nums[j++]);
                //ğŸªå¯¹å·¦ä¾§å…ƒç´ æ¥è¯´,ä¸€æ—¦ä¸å³ä¾§æŸå…ƒç´ å½¢æˆé€†åºå¯¹ï¼Œåˆ™å…¶åé¢æ‰€æœ‰å…ƒç´ éƒ½å½¢æˆé€†åºå¯¹
                pairs += mid - i + 1;
            } else {
                temp.push_back(nums[i++]);
            }
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int k = 0; k != temp.size(); ++k) nums[left + k] = temp[k];
    }  
};
```

### 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹
ğŸ¥‰è¾“å…¥ä¸¤ä¸ªé“¾è¡¨ï¼Œæ‰¾å‡ºå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚<br>
æ³¨æ„ï¼šå¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null. åœ¨è¿”å›ç»“æœåï¼Œä¸¤ä¸ªé“¾è¡¨ä»é¡»ä¿æŒåŸæœ‰çš„ç»“æ„ã€‚å¯å‡å®šæ•´ä¸ªé“¾è¡¨ç»“æ„ä¸­æ²¡æœ‰å¾ªç¯ã€‚ç¨‹åºå°½é‡æ»¡è¶³ O(n) æ—¶é—´å¤æ‚åº¦ï¼Œä¸”ä»…ç”¨ O(1) å†…å­˜ã€‚
```
è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
è¾“å‡ºï¼šReference of the node with value = 8
è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,0,1,8,4,5]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
```
---

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *currA = headA, *currB = headB;
        int lenA = 0,lenB = 0;
        while (currA) {
            lenA++;
            currA = currA->next;
        }
        while (currB) {
            lenB++;
            currB = currB->next;
        }
        
        //ğŸªæ’é™¤è¾ƒé•¿é“¾è¡¨å¤šå‡ºçš„éƒ¨åˆ†ååŒæ—¶éå†ä¸¤æ¡é“¾è¡¨,ç»“ç‚¹ç›¸åŒæ—¶å³ä¸ºç›¸äº¤èŠ‚ç‚¹
        currA = headA; currB = headB;
        while (lenA > lenB) {
            currA = currA->next;
            lenA--;
        } 
        while (lenA < lenB) {
            currB = currB->next;
            lenB--;
        }
        while (currA != currB) {
            currA = currA->next;
            currB = currB->next;
        }
        return currA;
    }
};
```

æ ‡ç­¾: `é“¾è¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *currA = headA, *currB = headB;
        //ğŸªåˆ†åˆ«ä»ä¸¤ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹éå†,å½“é‡åˆ°ç©ºèŠ‚ç‚¹æ—¶,è·³åˆ°å¦ä¸€ä¸ªé“¾è¡¨ç»§ç»­éå†
        while (currA != currB) {
            currA = currA ? currA->next : headB;
            currB = currB ? currB->next : headA;
        }
        return currA;
    }
};
```

### 53.
### 54.

### 55-I. äºŒå‰æ ‘çš„æ·±åº¦
ğŸ¥‰è¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ±‚è¯¥æ ‘çš„æ·±åº¦ã€‚ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ä¾æ¬¡ç»è¿‡çš„èŠ‚ç‚¹ï¼ˆå«æ ¹ã€å¶èŠ‚ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„é•¿åº¦ä¸ºæ ‘çš„æ·±åº¦ã€‚
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7] è¿”å›: 3 
    3
   / \
  9  20
    /  \
   15   7
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `DFS`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        //ğŸªæ ‘çš„æ·±åº¦ç­‰äºå…¶å·¦å­æ ‘æ·±åº¦ä¸å³å­æ ‘æ·±åº¦çš„æœ€å¤§å€¼+1
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

æ ‡ç­¾: `äºŒå‰æ ‘` `BFS`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        //ğŸªä½¿ç”¨BFSè¿›è¡Œå±‚åºéå†æ—¶è®°å½•æœ€ç»ˆçš„å±‚æ•°å³ä¸ºæœ€å¤§æ·±åº¦
        int res = 0;
        queue<TreeNode*> nodes;
        nodes.push(root);
        while (!nodes.empty()) {
            res++;
            int len = nodes.size();
            while (len--) {
                if (nodes.front()->left) nodes.push(nodes.front()->left);
                if (nodes.front()->right) nodes.push(nodes.front()->right);
                nodes.pop();
            }
        }
        return res;
    }
};
```
### 55-II. å¹³è¡¡äºŒå‰æ ‘
ğŸ¥‰è¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œåˆ¤æ–­è¯¥æ ‘æ˜¯ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚å¦‚æœæŸäºŒå‰æ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æ·±åº¦ç›¸å·®ä¸è¶…è¿‡1ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7] è¿”å›: true

    3
   / \
  9  20
    /  \
   15   7
```
---

æ ‡ç­¾: `äºŒå‰æ ‘` `è‡ªé¡¶å‘ä¸‹` `å…ˆåºéå†`<br>
æ—¶é—´å¤æ‚åº¦:`O(NlogN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (!root) return true;
        //ğŸªåˆ©ç”¨äºŒå‰æ ‘çš„æ·±åº¦è®¡ç®—,åˆ¤æ–­äºŒå‰æ ‘çš„æ¯ä¸ªç»“ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯å¦å¹³è¡¡(é«˜åº¦å·®â‰¤1)
        int diff = maxDepth(root->left) - maxDepth(root->right);
        if (diff > 1 || diff < -1) return false;
        return isBalanced(root->left) && isBalanced(root->right);
    }

    //ğŸªDFSé€’å½’æ±‚äºŒå‰æ ‘çš„æ·±åº¦
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

æ ‡ç­¾: `äºŒå‰æ ‘` `è‡ªåº•å‘ä¸Š` `ååºéå†`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (!root) return true;
        return heightBalance(root) == -1 ? false : true;
    }
    
    int heightBalance(TreeNode* root) {
        if (!root) return 0;
        //ğŸªå¦‚æœå·¦å­æ ‘æˆ–å³å­æ ‘ä¸å¹³è¡¡åˆ™ç›´æ¥è¿”å›-1(å½“å‰ç»“ç‚¹ä¸ºæ ¹çš„æ ‘ä¹Ÿä¸å¹³è¡¡)
        int left = heightBalance(root->left);
        if (left == -1) return -1;
        int right = heightBalance(root->right);
        if (right == -1) return -1;
        //ğŸªå¦‚æœå½“å‰ç»“ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦å·®â‰¤1åˆ™è¿”å›å½“å‰ç»“ç‚¹çš„é«˜åº¦,å¦åˆ™è¿”å›-1(ä¸å¹³è¡¡)
        return abs(left - right) < 2 ? max(left, right) + 1 : -1;
    }
};
```

### 56.
### 57.
### 58.
### 59.
### 60.

### 61.
### 62.
### 63.
### 64.
### 65.
### 66.
### 67.
### 68.
### 69.
### 70.

### 71.
### 72.
### 73.
### 74.
### 75.
### 76.
### 77.
### 78.
### 79.
### 80.
